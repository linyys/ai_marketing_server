# FastAPI 项目架构设计指南

## 项目概述

本文档基于一个成熟的 FastAPI 项目实践，总结了现代化 Web API 服务的架构设计模式和开发规范。项目采用分层架构设计，支持异步任务处理、用户认证、数据库操作等常见功能，可作为其他 FastAPI 项目的参考模板。

## 技术栈

### 核心框架

- **FastAPI**: 现代化的Python Web框架，支持自动API文档生成
- **SQLAlchemy**: Python SQL工具包和对象关系映射(ORM)
- **Pydantic**: 数据验证和设置管理库
- **Celery**: 分布式任务队列系统
- **Redis**: 内存数据库，用作Celery的消息代理和结果存储

### 数据库

- **MySQL**: 主数据库，存储用户、积分等业务数据

### 其他依赖

- **PyJWT**: JWT令牌处理
- **Passlib**: 密码哈希处理
- **Uvicorn**: ASGI服务器
- **Docker**: 容器化部署

## 项目结构

```
class_bot_server/
├── .gitignore                    # Git忽略文件配置
├── Dockerfile                    # Docker镜像构建文件
├── class_bot_server.sql          # 数据库初始化脚本
├── config.ini                    # 项目配置文件
├── docker-compose.yml            # Docker Compose配置
├── requirements.txt              # Python依赖包列表
├── start.py                      # 项目启动脚本
└── src/                          # 源代码目录
    ├── main.py                   # FastAPI应用主入口
    ├── celery_worker.py          # Celery工作进程
    ├── crud/                     # 数据库CRUD操作层
    ├── db/                       # 数据库模型和配置
    ├── modules/                  # 业务模块
    ├── schemas/                  # Pydantic数据模型
    ├── tasks/                    # Celery异步任务
    └── utils/                    # 工具类和公共函数
```

### 目录详细说明

#### `/src/crud/` - 数据访问层

负责数据库的增删改查操作，每个业务实体对应一个CRUD文件：

- 实现标准的 CRUD 操作（Create, Read, Update, Delete）
- 封装复杂的数据库查询逻辑
- 处理数据库事务和异常
- 提供数据访问的统一接口

#### `/src/db/` - 数据库层

包含数据库模型定义和配置：

- `database.py` - 数据库连接和会话管理
- `config.py` - 数据库配置和设置
- 各业务实体的SQLAlchemy模型文件
- 数据库迁移和初始化脚本

#### `/src/modules/` - 业务模块层

按功能划分的业务模块，每个模块包含路由和控制器：

- 每个模块独立管理特定业务功能
- 包含 `router.py`（路由定义）和 `controller.py`（业务逻辑）
- 模块间通过明确的接口进行交互
- 支持模块的独立开发和测试

#### `/src/schemas/` - 数据模型层

使用Pydantic定义的数据验证和序列化模型：

- 请求/响应数据模型定义
- 数据验证规则和自定义验证器
- API文档自动生成支持
- 类型安全和数据转换

#### `/src/tasks/` - 异步任务层

使用Celery实现的异步任务：

- 长时间运行的后台任务
- 定时任务和周期性任务
- 任务状态监控和管理
- 分布式任务处理

#### `/src/utils/` - 工具类层

公共工具函数和中间件：

- `auth.py` - 认证和授权工具
- `jwt_utils.py` - JWT令牌处理
- `celery_app.py` - Celery应用配置
- `config.py` - 配置文件管理
- `redis_pool.py` - Redis连接池
- 其他通用工具和中间件

## 架构设计模式

### 分层架构

项目采用经典的分层架构模式：

```
┌─────────────────┐
│   Router Layer  │  # 路由层 - 处理HTTP请求路由
├─────────────────┤
│ Controller Layer│  # 控制器层 - 业务逻辑处理
├─────────────────┤
│   CRUD Layer    │  # 数据访问层 - 数据库操作
├─────────────────┤
│   Model Layer   │  # 模型层 - 数据库模型定义
└─────────────────┘
```

### 模块化设计

每个业务功能都被组织成独立的模块，模块内部结构统一：

- `router.py` - 定义API路由和请求处理
- `controller.py` - 实现业务逻辑

## 编码规范

### 命名规范

- **函数和变量**: 使用下划线命名法 (snake_case)
- **类名**: 使用帕斯卡命名法 (PascalCase)
- **常量**: 使用全大写下划线命名法 (UPPER_SNAKE_CASE)
- **文件名**: 使用下划线命名法

### 路由控制器实现规范

#### 1. 路由定义规范

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from db.database import get_db
from schemas.entity import EntityCreate, EntityOut
from . import controller
from utils.auth import get_current_user

router = APIRouter(tags=["entity"])

@router.post("/create", response_model=EntityOut, status_code=status.HTTP_201_CREATED)
async def create_entity(entity: EntityCreate, db: Session = Depends(get_db)):
    return controller.create_entity(db, entity)

@router.get("/list", response_model=List[EntityOut])
async def list_entities(
    skip: int = Query(0, ge=0),
    limit: int = Query(20, ge=1, le=100),
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    return controller.list_entities(db, skip, limit)
```

#### 2. 控制器实现规范

```python
from sqlalchemy.orm import Session
from schemas.entity import EntityCreate, EntityOut
from crud.entity import create_entity, get_entities
from typing import List

def create_entity(db: Session, entity: EntityCreate) -> EntityOut:
    """创建实体"""
    db_entity = create_entity(db, entity)
    return EntityOut.from_orm(db_entity)

def list_entities(db: Session, skip: int = 0, limit: int = 20) -> List[EntityOut]:
    """获取实体列表"""
    entities = get_entities(db, skip=skip, limit=limit)
    return [EntityOut.from_orm(entity) for entity in entities]
```

#### 3. 错误处理规范

```python
@router.get("/detail/{entity_id}", response_model=EntityOut)
async def get_entity_detail(entity_id: str, db: Session = Depends(get_db)):
    entity = controller.get_entity_by_id(db, entity_id)
    if not entity:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="实体不存在"
        )
    return entity

@router.put("/update/{entity_id}", response_model=EntityOut)
async def update_entity(
    entity_id: str,
    update_data: EntityUpdate,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    try:
        entity = controller.update_entity(db, entity_id, update_data)
        return entity
    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
```

### 数据库模型规范

#### 1. 模型定义规范

```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Text, func
from sqlalchemy.dialects.mysql import CHAR
from db.database import Base

class BaseEntity(Base):
    """基础实体模型"""
    __abstract__ = True
  
    id = Column(Integer, primary_key=True, index=True)
    created_time = Column(DateTime, nullable=False, server_default=func.now())
    updated_time = Column(DateTime, nullable=False, server_default=func.now(), onupdate=func.now())
    is_deleted = Column(Boolean, default=False, nullable=False)

class Entity(BaseEntity):
    """具体业务实体"""
    __tablename__ = "entities"
  
    uuid = Column(CHAR(36), unique=True, index=True, nullable=False)
    name = Column(String(100), nullable=False, index=True)
    description = Column(Text, nullable=True)
    status = Column(String(20), default="active", nullable=False)
  
    def __repr__(self):
        return f"<Entity(uuid={self.uuid}, name={self.name})>"
```

#### 2. CRUD操作规范

```python
from sqlalchemy.orm import Session
from sqlalchemy import and_
from db.entity import Entity
from schemas.entity import EntityCreate, EntityUpdate
from typing import List, Optional
import uuid

def get_entity_by_uuid(db: Session, entity_uuid: str) -> Optional[Entity]:
    """根据UUID获取实体"""
    return db.query(Entity).filter(
        and_(Entity.uuid == entity_uuid, Entity.is_deleted == False)
    ).first()

def get_entities(db: Session, skip: int = 0, limit: int = 20) -> List[Entity]:
    """获取实体列表"""
    return db.query(Entity).filter(
        Entity.is_deleted == False
    ).offset(skip).limit(limit).all()

def create_entity(db: Session, entity: EntityCreate) -> Entity:
    """创建实体"""
    db_entity = Entity(
        uuid=str(uuid.uuid4()),
        name=entity.name,
        description=entity.description,
        status=entity.status or "active"
    )
    db.add(db_entity)
    db.commit()
    db.refresh(db_entity)
    return db_entity

def update_entity(db: Session, entity_uuid: str, update_data: EntityUpdate) -> Optional[Entity]:
    """更新实体"""
    entity = get_entity_by_uuid(db, entity_uuid)
    if not entity:
        return None
  
    update_dict = update_data.dict(exclude_unset=True)
    for field, value in update_dict.items():
        setattr(entity, field, value)
  
    db.commit()
    db.refresh(entity)
    return entity

def soft_delete_entity(db: Session, entity_uuid: str) -> bool:
    """软删除实体"""
    entity = get_entity_by_uuid(db, entity_uuid)
    if not entity:
        return False
  
    entity.is_deleted = True
    db.commit()
    return True
```

### Pydantic模型规范

#### 1. 请求模型定义

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional
from enum import Enum
import re

class EntityStatus(str, Enum):
    """实体状态枚举"""
    ACTIVE = "active"
    INACTIVE = "inactive"
    PENDING = "pending"
    ARCHIVED = "archived"

class EntityCreate(BaseModel):
    """创建实体请求模型"""
    name: str = Field(..., min_length=1, max_length=100, description="实体名称")
    description: Optional[str] = Field(None, max_length=500, description="实体描述")
    status: Optional[EntityStatus] = Field(EntityStatus.ACTIVE, description="实体状态")
  
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: str) -> str:
        v = v.strip()
        if not v:
            raise ValueError('名称不能为空')
        if not re.match(r'^[\w\s\-\.]+$', v):
            raise ValueError('名称只能包含字母、数字、空格、下划线、连字符和点')
        return v

class EntityUpdate(BaseModel):
    """更新实体请求模型"""
    name: Optional[str] = Field(None, min_length=1, max_length=100)
    description: Optional[str] = Field(None, max_length=500)
    status: Optional[EntityStatus] = None
  
    @field_validator('name')
    @classmethod
    def validate_name(cls, v: Optional[str]) -> Optional[str]:
        if v is not None:
            v = v.strip()
            if not v:
                raise ValueError('名称不能为空')
            if not re.match(r'^[\w\s\-\.]+$', v):
                raise ValueError('名称只能包含字母、数字、空格、下划线、连字符和点')
        return v
```

#### 2. 响应模型定义

```python
from datetime import datetime
from typing import List, Optional

class EntityOut(BaseModel):
    """实体响应模型"""
    uuid: str
    name: str
    description: Optional[str]
    status: EntityStatus
    created_time: datetime
    updated_time: datetime
  
    class Config:
        from_attributes = True  # Pydantic v2
        # orm_mode = True  # Pydantic v1
      
        json_schema_extra = {
            "example": {
                "uuid": "123e4567-e89b-12d3-a456-426614174000",
                "name": "示例实体",
                "description": "这是一个示例实体",
                "status": "active",
                "created_time": "2023-01-01T12:00:00",
                "updated_time": "2023-01-01T12:00:00"
            }
        }

class EntityListResponse(BaseModel):
    """实体列表响应模型"""
    total: int = Field(..., description="总数量")
    items: List[EntityOut] = Field(..., description="实体列表")
    skip: int = Field(..., description="跳过数量")
    limit: int = Field(..., description="限制数量")

class PaginationParams(BaseModel):
    """分页参数模型"""
    skip: int = Field(0, ge=0, description="跳过记录数")
    limit: int = Field(20, ge=1, le=100, description="返回记录数限制")
```

### 认证和授权规范

#### 1. JWT令牌处理

```python
from datetime import datetime, timedelta, timezone
import jwt

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.token_expire_minutes)
  
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.jwt_secret, algorithm=settings.jwt_algo)
    return encoded_jwt
```

#### 2. 认证依赖注入

```python
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer

security = HTTPBearer()

def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), db: Session = Depends(get_db)):
    payload = verify_token(credentials.credentials)
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="无效的认证凭据"
        )
  
    user_id = payload.get("sub")
    user = get_user_by_uid(db, user_id)
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="用户不存在"
        )
  
    return user
```

### 异步任务规范

#### 1. Celery任务定义

```python
from utils.celery_app import celery_app
from typing import Dict, Any, Optional
import redis
import json
import logging
from datetime import datetime

# Redis连接
redis_client = redis.Redis(host='localhost', port=6379, db=0)
logger = logging.getLogger(__name__)

@celery_app.task(bind=True)
def process_data_task(self, data: Dict[str, Any], task_type: str = "default") -> Dict[str, Any]:
    """通用数据处理任务"""
    try:
        # 任务去重和并发控制
        task_key = f"data_task:{task_type}:{self.request.id}"
        if redis_client.exists(task_key):
            logger.warning(f"Task {self.request.id} already exists")
            return {"status": "duplicate", "message": "任务已存在", "task_id": self.request.id}
      
        # 设置任务状态，5分钟过期
        redis_client.setex(task_key, 300, json.dumps({
            "status": "processing",
            "started_at": datetime.now().isoformat(),
            "task_type": task_type
        }))
      
        # 更新任务进度
        self.update_state(state='PROGRESS', meta={'current': 0, 'total': 100, 'status': '开始处理...'})
      
        # 实际的数据处理逻辑
        result = perform_data_processing(data, task_type, progress_callback=lambda p: self.update_state(
            state='PROGRESS', 
            meta={'current': p, 'total': 100, 'status': f'处理中... {p}%'}
        ))
      
        # 清理Redis状态
        redis_client.delete(task_key)
      
        return {
            "status": "success", 
            "result": result,
            "task_id": self.request.id,
            "completed_at": datetime.now().isoformat()
        }
      
    except Exception as exc:
        # 清理Redis状态
        redis_client.delete(task_key)
        logger.error(f"Task {self.request.id} failed: {str(exc)}")
      
        # 重试机制
        raise self.retry(exc=exc, countdown=60, max_retries=3)

@celery_app.task(bind=True)
def batch_process_task(self, items: list, batch_size: int = 10) -> Dict[str, Any]:
    """批量处理任务"""
    try:
        total_items = len(items)
        processed_items = []
        failed_items = []
      
        for i in range(0, total_items, batch_size):
            batch = items[i:i + batch_size]
          
            # 更新进度
            progress = int((i / total_items) * 100)
            self.update_state(
                state='PROGRESS',
                meta={
                    'current': i,
                    'total': total_items,
                    'status': f'处理批次 {i//batch_size + 1}...',
                    'progress': progress
                }
            )
          
            # 处理当前批次
            batch_result = process_batch(batch)
            processed_items.extend(batch_result.get('success', []))
            failed_items.extend(batch_result.get('failed', []))
      
        return {
            "status": "completed",
            "total_processed": len(processed_items),
            "total_failed": len(failed_items),
            "processed_items": processed_items,
            "failed_items": failed_items,
            "task_id": self.request.id
        }
      
    except Exception as exc:
        logger.error(f"Batch task {self.request.id} failed: {str(exc)}")
        raise self.retry(exc=exc, countdown=30, max_retries=2)

def perform_data_processing(data: Dict[str, Any], task_type: str, progress_callback: Optional[callable] = None) -> Dict[str, Any]:
    """执行数据处理逻辑"""
    # 模拟处理步骤
    steps = ['validation', 'transformation', 'processing', 'finalization']
    result = {"processed_data": data, "steps_completed": []}
  
    for i, step in enumerate(steps):
        # 模拟处理时间
        import time
        time.sleep(1)
      
        # 更新进度
        if progress_callback:
            progress_callback(int((i + 1) / len(steps) * 100))
      
        result["steps_completed"].append(step)
  
    return result

def process_batch(batch: list) -> Dict[str, list]:
    """处理单个批次"""
    success = []
    failed = []
  
    for item in batch:
        try:
            # 模拟处理逻辑
            processed_item = {"original": item, "processed": True, "timestamp": datetime.now().isoformat()}
            success.append(processed_item)
        except Exception as e:
            failed.append({"item": item, "error": str(e)})
  
    return {"success": success, "failed": failed}
```

#### 2. 任务调用

```python
from tasks.data_tasks import process_data_task, batch_process_task
from celery.result import AsyncResult
from typing import Dict, Any, List, Optional
import logging

logger = logging.getLogger(__name__)

# 异步调用单个数据处理任务
def submit_data_processing_task(data: Dict[str, Any], task_type: str = "default") -> Dict[str, str]:
    """提交数据处理任务"""
    try:
        task = process_data_task.delay(data, task_type)
        logger.info(f"Submitted data processing task {task.id} with type {task_type}")
        return {
            "task_id": task.id,
            "status": "submitted",
            "task_type": task_type
        }
    except Exception as e:
        logger.error(f"Failed to submit data processing task: {str(e)}")
        raise

# 异步调用批量处理任务
def submit_batch_processing_task(items: List[Any], batch_size: int = 10) -> Dict[str, Any]:
    """提交批量处理任务"""
    try:
        task = batch_process_task.delay(items, batch_size)
        logger.info(f"Submitted batch processing task {task.id} with {len(items)} items")
        return {
            "task_id": task.id,
            "status": "submitted",
            "total_items": len(items),
            "batch_size": batch_size
        }
    except Exception as e:
        logger.error(f"Failed to submit batch processing task: {str(e)}")
        raise

# 查询任务状态
def get_task_status(task_id: str) -> Dict[str, Any]:
    """获取任务状态"""
    try:
        result = AsyncResult(task_id)
      
        if result.state == 'PENDING':
            response = {
                'task_id': task_id,
                'state': result.state,
                'status': '任务等待中...',
                'progress': 0
            }
        elif result.state == 'PROGRESS':
            info = result.info or {}
            response = {
                'task_id': task_id,
                'state': result.state,
                'current': info.get('current', 0),
                'total': info.get('total', 100),
                'progress': info.get('progress', info.get('current', 0)),
                'status': info.get('status', '处理中...')
            }
        elif result.state == 'SUCCESS':
            response = {
                'task_id': task_id,
                'state': result.state,
                'result': result.result,
                'progress': 100,
                'status': '任务完成'
            }
        elif result.state == 'FAILURE':
            response = {
                'task_id': task_id,
                'state': result.state,
                'error': str(result.info),
                'progress': 0,
                'status': '任务失败'
            }
        else:
            response = {
                'task_id': task_id,
                'state': result.state,
                'status': f'未知状态: {result.state}',
                'progress': 0
            }
      
        return response
      
    except Exception as e:
        logger.error(f"Failed to get task status for {task_id}: {str(e)}")
        return {
            'task_id': task_id,
            'state': 'ERROR',
            'error': f'查询任务状态失败: {str(e)}',
            'progress': 0,
            'status': '查询失败'
        }

# 取消任务
def cancel_task(task_id: str) -> Dict[str, Any]:
    """取消任务"""
    try:
        result = AsyncResult(task_id)
        result.revoke(terminate=True)
        logger.info(f"Cancelled task {task_id}")
        return {
            'task_id': task_id,
            'status': 'cancelled',
            'message': '任务已取消'
        }
    except Exception as e:
        logger.error(f"Failed to cancel task {task_id}: {str(e)}")
        return {
            'task_id': task_id,
            'status': 'error',
            'error': f'取消任务失败: {str(e)}'
        }

# 批量查询任务状态
def get_multiple_task_status(task_ids: List[str]) -> Dict[str, Dict[str, Any]]:
    """批量查询任务状态"""
    results = {}
    for task_id in task_ids:
        results[task_id] = get_task_status(task_id)
    return results
```

#### 3. 任务状态管理

```python
# 使用Redis进行任务状态跟踪
from utils.redis_pool import get_redis_client, set_counter, increment_counter

@task_prerun.connect
def task_prerun_handler(sender=None, task_id=None, task=None, **kwargs):
    if task.name == 'tasks.tts.create_audio':
        increment_counter(TTS_RUNNING_TASKS_KEY)

@task_postrun.connect
def task_postrun_handler(sender=None, task_id=None, task=None, **kwargs):
    if task.name == 'tasks.tts.create_audio':
        decrement_counter(TTS_RUNNING_TASKS_KEY)
```

## 部署和运行

### 本地开发环境

1. 安装依赖：`pip install -r requirements.txt`
2. 配置数据库和Redis连接
3. 运行应用：`python start.py`

### Docker部署

1. 构建镜像：`docker build -t class-bot-server .`
2. 使用docker-compose：`docker-compose up -d`

### 生产环境

- 使用Nginx作为反向代理
- 配置SSL证书
- 设置环境变量和配置文件
- 监控和日志收集

## 最佳实践

### 代码质量

1. **减少不必要的代码注释**：代码应该自解释，只在复杂逻辑处添加注释
2. **提取可复用逻辑**：避免代码重复，提高代码聚合度
3. **优先使用项目已有的封装函数**：避免重复造轮子
4. **避免防御性编程**：在完全控制代码库的情况下，直接修复问题而不是添加兼容层

### 安全性

1. **密码哈希**：使用bcrypt进行密码哈希
2. **JWT令牌**：设置合理的过期时间
3. **输入验证**：使用Pydantic进行严格的数据验证
4. **权限控制**：实现基于角色的访问控制

### 性能优化

1. **数据库连接池**：使用SQLAlchemy连接池
2. **Redis缓存**：缓存频繁访问的数据
3. **异步处理**：使用Celery处理耗时任务
4. **分页查询**：大数据量查询使用分页

### 错误处理

1. **统一错误响应格式**：使用HTTPException返回标准错误
2. **日志记录**：记录关键操作和错误信息
3. **优雅降级**：在服务不可用时提供备选方案

## 扩展指南

### 添加新模块

1. 在`/src/modules/`下创建新目录
2. 创建`router.py`和`controller.py`文件
3. 在`/src/db/`下添加数据库模型
4. 在`/src/crud/`下添加CRUD操作
5. 在`/src/schemas/`下添加Pydantic模型
6. 在`main.py`中注册路由

### 添加新的异步任务

1. 在`/src/tasks/`下创建任务文件
2. 在`celery_app.py`中注册任务模块
3. 实现任务逻辑和错误处理
4. 添加任务状态监控

### 数据库迁移

1. 修改数据库模型
2. 生成迁移脚本
3. 在生产环境中谨慎执行迁移
4. 备份数据库

本文档将随着项目的发展持续更新，确保与实际代码保持同步。
